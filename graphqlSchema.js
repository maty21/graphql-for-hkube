const { ApolloServer, gql } = require('apollo-server');
const { graphqlSync } = require('graphql');
const { Kind } = require('graphql/language')
const jobTypeDefs = gql`

scalar Object

type Results { startTime: Int
    pipeline: String
    status: String
    timestamp: Int
    timeTook: Float
    data: Data }
  
  type Discovery { host: String port: String }
  

  
  type Metadata { values: Object }
  
  type StorageInfo { path: String size: Int }
  
  type Output { taskId: String
    discovery: Discovery
    metadata: Metadata
    storageInfo: StorageInfo }
  
  type Input { path: String }
  
  type Nodes { nodeName: String
    algorithmName: String
    taskId: String
    podName: String
    status: String
    startTime: Int
    endTime: Int
    level: Int
    batch: String
    boards: [String ]
    output: Output
    input: [Input ] }
  
  type Value { types: [String ] }
  
  type Edges { from: String to: String value: Value }
  
  type Graph { jobId: String
    timestamp: Int
    nodes: [Nodes ]
    edges: [Edges ] }
  
  type States { succeed: Int }
  
  type Data { progress: Int details: String states: States }
  
  type Status { timestamp: Int
    status: String
    level: String
    pipeline: String
    data: Data }
  
  type LastRunResult { timestamp: Int status: String timeTook: Float }
  

  
  type FlowInputMetadata { storageInfo: StorageInfo metadata: Metadata }
  
  type Cron { enabled: Boolean pattern: String }
  
  type Triggers { cron: Cron }
  
  type Options { batchTolerance: Int
    progressVerbosityLevel: String
    ttl: Int }
  
  type Files { link: String }
  
  type FlowInput { files: Files }
  
  type Pipeline { name: String
    experimentName: String
    kind: String
    priority: Int
    startTime: Int
    types: [String ]
    lastRunResult: LastRunResult
    flowInputMetadata: FlowInputMetadata
    triggers: Triggers
    options: Options
    flowInput: FlowInput
    nodes: [Nodes ] }
  
  type UserPipeline { name: String
    experimentName: String
    triggers: Triggers
    options: Options
    flowInput: FlowInput
    nodes: [Nodes ] }
  
  type Jobs { key: String
    results: Results
    graph: Graph
    status: Status
    pipeline: Pipeline
    userPipeline: UserPipeline }
  
  type AutogeneratedMainType { jobs: [Jobs ] }
  
  # Types with identical fields:
  # Green FlowInputfileslink

`
const discoveryTypeDefs = gql`

type Pipelinedriver {
     driverId: String
    paused: Boolean
    driverStatus: String
    jobStatus: String
    podName: String }
  
  type Workers { total: Int stats: [String ] }
  
  type Labels { 
    betaubernetesioarch: String
    betakubernetesioinstancetype: String
    betakubernetesioos: String
    failuredomainbetakubernetesioregion: String
    failuredomainbetakubernetesiozone: String
    kopsk8sioinstancegroup: String
    kubernetesioarch: String
    kubernetesiohostname: String
    kubernetesioos: String
    kubernetesiorole: String
    noderolekubernetesionode: String
    noderolekubernetesiospotworker: String
    nodekubernetesioinstancetype: String
    ondemand: String
    topologykubernetesioregion: String
    topologykubernetesiozone: String }
  
  type WorkersTotal { cpu: Int gpu: Int mem: Int }
  
  type Other { cpu: Float gpu: Int mem: Int }
  
  type Requests { cpu: Float gpu: Int mem: Int }
  
  type Total { cpu: Int gpu: Int mem: Float }
  
  type Nodes { name: String
    workers: Workers
    workers2: [String ]
    labels: Labels
    workersTotal: WorkersTotal
    other: Other
    requests: Requests
    total: Total }
  
  type ResourcePressure { cpu: Float gpu: Int mem: Float }
  
  type Stats { algorithmName: String count: Int results: Int }
  
  type Actual { total: Int stats: [Stats ] }
  
  type TaskExecutor { 
    nodes: [Nodes ]
    resourcePressure: ResourcePressure
    actual: Actual 
}
  
  type StreamingDiscovery { host: String port: Int }
  
  type Worker { 
    workerStatus: String
    isMaster: Boolean
    workerStartingTime: String
    jobCurrentTime: String
    workerPaused: Boolean
    hotWorker: Boolean
    error: String
    workerId: String
    algorithmName: String
    podName: String
    streamingDiscovery: StreamingDiscovery }
  
  type Discovery { pipelinedriver: [Pipelinedriver ]
    TaskExecutor: [TaskExecutor ]
    worker: [Worker ] }
  
  type AutogeneratedMainType { discovery: Discovery }
`
const algorithmTpeDefs = gql`
type Options { debug: Boolean pending: Boolean }

type Commit { id: String timestamp: String message: String }

type GitRepository { gitKind: String
  url: String
  branchName: String
  webUrl: String
  cloneUrl: String
  commit: Commit }

type Algorithms { name: String
  cpu: Int
  created: Int
  entryPoint: String
  env: String
  gpu: Int
  mem: String
  minHotWorkers: Int
  modified: Int
  reservedMemory: String
  type: String
  algorithmImage: String
  version: String
  options: Options
  gitRepository: GitRepository }

type AutogeneratedMainType { algorithms: [Algorithms ] }
`
const pipelineTpeDefs = gql`
type Cron { enabled: Boolean pattern: String }

type Triggers { cron: Cron }

type ConcurrentPipelines { amount: Int rejectOnFailure: Boolean }

type Options { batchTolerance: Int
  ttl: Int
  progressVerbosityLevel: String
  concurrentPipelines: ConcurrentPipelines }

type Metrics { tensorboard: Boolean }

type Retry { policy: String limit: Int }

type Nodes { nodeName: String
  algorithmName: String
  ttl: Int
  includeInResult: Boolean
  batchOperation: String
  metrics: Metrics
  retry: Retry
  input: [String ] }

type FlowInput { mul: Int data: Int }

type Pipelines { modified: Int
  kind: String
  name: String
  priority: Int
  experimentName: String
  triggers: Triggers
  options: Options
  nodes: [Nodes ]
  flowInput: FlowInput }

type AutogeneratedMainType { pipelines: [Pipelines ] }
`
const experimentTpeDefs = gql`
type Experiments {
     name: String 
     description: String
      created: Int 
    }

type AutogeneratedMainType { 
    experiments: [Experiments ]
 }
`
const nodeStatisticTpeDefs = gql` 
type AlgorithmsData { name: String amount: Int size: Float }

type Results { name: String algorithmsData: [AlgorithmsData ] }

type NodeStatistics { metric: String
  legend: [String ]
  results: [Results ] }
`
const diskSpaceTpeDefs = gql`
type DiskSpace { size: Int free: Int }
`
const pipelineStatsTpeDefs = gql`
type Stats { status: String count: Int }
type PipelinesStats { name: String stats: [Stats ] }
`
const dataSourcesTypeDefs = gql`

type DataSources { 
    versionDescription: String
    name: String
    filesCount: Int
    avgFileSize: Float
    totalSize: Int
    id: String
    fileTypes: [String ]
 }
`

const algorithmBuildsTypeDefs = gql`type Result { data: String warnings: String errors: String }

type Commit { id: String timestamp: String message: String }

type GitRepository { gitKind: String
  url: String
  branchName: String
  webUrl: String
  cloneUrl: String
  commit: Commit }

type Options { debug: Boolean pending: Boolean }

type Algorithm { name: String
  cpu: Int
  gpu: Int
  mem: String
  reservedMemory: String
  minHotWorkers: Int
  env: String
  entryPoint: String
  type: String
  options: Options
  gitRepository: GitRepository }

type AlgorithmBuild {
     buildId: String
  imageTag: String
  env: String
  algorithmName: String
  type: String
  status: String
  progress: Int
  error: String
  trace: String
  endTime: Int
  startTime: Int
  timestamp: Int
  algorithmImage: String
  buildMode: String
  result: Result
  gitRepository: GitRepository
  algorithm: Algorithm
 }`


const ObjectScalarType = new GraphQLScalarType({
    name: 'Object',
    description: 'Arbitrary object',
    parseValue: (value) => {
        return typeof value === 'object' ? value
            : typeof value === 'string' ? JSON.parse(value)
                : null
    },
    serialize: (value) => {
        return typeof value === 'object' ? value
            : typeof value === 'string' ? JSON.parse(value)
                : null
    },
    parseLiteral: (ast) => {
        switch (ast.kind) {
            case Kind.STRING: return JSON.parse(ast.value)
            case Kind.OBJECT: throw new Error(`Not sure what to do with OBJECT for ObjectScalarType`)
            default: return null
        }
    }
})